diff --git a/libs/avs-core/CMakeLists.txt b/libs/avs-core/CMakeLists.txt
index 6163b3cfab98f662a7e2f55c67606396ffc17af2..d44faff61116694febd69a38b537778d266d7a62 100644
--- a/libs/avs-core/CMakeLists.txt
+++ b/libs/avs-core/CMakeLists.txt
@@ -1,22 +1,23 @@
 add_library(avs-core STATIC
   src/core.cpp
   src/engine.cpp
   src/eel.cpp
   src/cpu_features.cpp
   src/effects/blur.cpp
   src/effects/colormap.cpp
   src/effects/convolution.cpp
   src/effects/motion_blur.cpp
   src/effects/color_transform.cpp
   src/effects/glow.cpp
   src/effects/zoom_rotate.cpp
   src/effects/mirror.cpp
   src/effects/tunnel.cpp
   src/effects/radial_blur.cpp
   src/effects/additive_blend.cpp
+  src/effects/composite.cpp
   src/effects/scripted.cpp
   src/preset.cpp
 )
 target_include_directories(avs-core PUBLIC include ../avs-platform/include)
 target_compile_options(avs-core PRIVATE -Wall -Wextra -Werror)
 target_link_libraries(avs-core PUBLIC ns-eel)
diff --git a/libs/avs-core/include/avs/effects.hpp b/libs/avs-core/include/avs/effects.hpp
index aec7ac198396395fe5648206878d34e2344bd0ca..f99f8389112f481002db42307f78a524a31d38dc 100644
--- a/libs/avs-core/include/avs/effects.hpp
+++ b/libs/avs-core/include/avs/effects.hpp
@@ -1,53 +1,70 @@
 #pragma once
 
 #include <array>
 #include <cstdint>
+#include <memory>
 #include <string>
 #include <vector>
 
 #include "avs/audio.hpp"
 #include "avs/eel.hpp"
 
 namespace avs {
 
 struct Framebuffer {
   int w = 0;
   int h = 0;
   std::vector<std::uint8_t> rgba;
 };
 
 class Effect {
  public:
   virtual ~Effect() = default;
   virtual void init(int w, int h) {
     (void)w;
     (void)h;
   }
   virtual void process(const Framebuffer& in, Framebuffer& out) = 0;
 };
 
+class CompositeEffect : public Effect {
+ public:
+  void addEffect(std::unique_ptr<Effect> effect);
+  void init(int w, int h) override;
+  void process(const Framebuffer& in, Framebuffer& out) override;
+
+  size_t childCount() const { return children_.size(); }
+  const std::vector<std::unique_ptr<Effect>>& children() const { return children_; }
+
+ private:
+  std::vector<std::unique_ptr<Effect>> children_;
+  Framebuffer buffers_[2];
+  int width_ = 0;
+  int height_ = 0;
+};
+
 class BlurEffect : public Effect {
  public:
   explicit BlurEffect(int radius = 5);
   void init(int w, int h) override;
   void process(const Framebuffer& in, Framebuffer& out) override;
 
  private:
   int radius_;
   std::vector<float> kernel_;
   Framebuffer temp_;
 };
 
 class ColorMapEffect : public Effect {
  public:
   void init(int w, int h) override;
   void process(const Framebuffer& in, Framebuffer& out) override;
 
  private:
   std::array<std::uint8_t, 256 * 3> lut_;
 };
 
 class ConvolutionEffect : public Effect {
  public:
   void init(int w, int h) override;
   void process(const Framebuffer& in, Framebuffer& out) override;
diff --git a/libs/avs-core/include/avs/preset.hpp b/libs/avs-core/include/avs/preset.hpp
index 3641c2cded6e87cf4d5566eae061ae4404e1c943..5e80e6a26f0b961fe80f6392be9016205eb66146 100644
--- a/libs/avs-core/include/avs/preset.hpp
+++ b/libs/avs-core/include/avs/preset.hpp
@@ -1,20 +1,21 @@
 #pragma once
 
 #include <filesystem>
 #include <memory>
 #include <string>
 #include <vector>
 
 #include "avs/effects.hpp"
 
 namespace avs {
 
 struct ParsedPreset {
   std::vector<std::unique_ptr<Effect>> chain;
   std::vector<std::string> warnings;
   std::vector<std::string> unknown;
+  std::vector<std::string> comments;
 };
 
 ParsedPreset parsePreset(const std::filesystem::path& file);
 
 }  // namespace avs
diff --git a/libs/avs-core/src/effects/composite.cpp b/libs/avs-core/src/effects/composite.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..3789f30395ed5849ebba29b6086472c132d131f9
--- /dev/null
+++ b/libs/avs-core/src/effects/composite.cpp
@@ -0,0 +1,64 @@
+#include "avs/effects.hpp"
+
+namespace avs {
+
+void CompositeEffect::addEffect(std::unique_ptr<Effect> effect) {
+  if (effect) {
+    children_.push_back(std::move(effect));
+  }
+}
+
+void CompositeEffect::init(int w, int h) {
+  width_ = w;
+  height_ = h;
+  for (auto& child : children_) {
+    child->init(w, h);
+  }
+  for (auto& buffer : buffers_) {
+    buffer.w = w;
+    buffer.h = h;
+    buffer.rgba.resize(static_cast<size_t>(w) * static_cast<size_t>(h) * 4u);
+  }
+}
+
+void CompositeEffect::process(const Framebuffer& in, Framebuffer& out) {
+  if (children_.empty()) {
+    out = in;
+    return;
+  }
+
+  if (width_ == 0 || height_ == 0) {
+    width_ = in.w;
+    height_ = in.h;
+    for (auto& child : children_) {
+      child->init(width_, height_);
+    }
+  }
+
+  const Framebuffer* currentIn = &in;
+  int bufferIndex = 0;
+  for (size_t i = 0; i < children_.size(); ++i) {
+    bool last = (i + 1 == children_.size());
+    Framebuffer* target = nullptr;
+    if (last) {
+      out.w = width_;
+      out.h = height_;
+      out.rgba.resize(static_cast<size_t>(width_) * static_cast<size_t>(height_) * 4u);
+      target = &out;
+    } else {
+      Framebuffer& buffer = buffers_[bufferIndex];
+      buffer.w = width_;
+      buffer.h = height_;
+      buffer.rgba.resize(static_cast<size_t>(width_) * static_cast<size_t>(height_) * 4u);
+      target = &buffer;
+    }
+    children_[i]->process(*currentIn, *target);
+    currentIn = target;
+    if (!last) {
+      bufferIndex ^= 1;
+    }
+  }
+}
+
+}  // namespace avs
+
diff --git a/libs/avs-core/src/preset.cpp b/libs/avs-core/src/preset.cpp
index 6298154dcbd238aa5bc7586788c073df9ea3c012..d9f7552cfb273ec489e956ff0689e3b57bbba226 100644
--- a/libs/avs-core/src/preset.cpp
+++ b/libs/avs-core/src/preset.cpp
@@ -5,161 +5,260 @@
 #include <cctype>
 #include <cstdint>
 #include <fstream>
 #include <iterator>
 #include <sstream>
 #include <string>
 #include <vector>
 
 namespace avs {
 
 namespace {
 std::string trim(const std::string& s) {
   size_t b = 0;
   while (b < s.size() && std::isspace(static_cast<unsigned char>(s[b]))) ++b;
   size_t e = s.size();
   while (e > b && std::isspace(static_cast<unsigned char>(s[e - 1]))) --e;
   return s.substr(b, e - b);
 }
 
 class PassThroughEffect : public Effect {
  public:
   void process(const Framebuffer& in, Framebuffer& out) override { out = in; }
 };
 
 constexpr const char kMagic[] = "Nullsoft AVS Preset 0.2\x1a";
+constexpr std::uint32_t kListId = 0xFFFFFFFEu;
 
 struct Reader {
   const std::vector<char>& data;
   size_t pos = 0;
 
   size_t remaining() const { return data.size() - pos; }
 };
 
 bool readByte(Reader& r, std::uint8_t& value) {
   if (r.pos >= r.data.size()) return false;
   value = static_cast<std::uint8_t>(r.data[r.pos++]);
   return true;
 }
 
 bool readU32(Reader& r, std::uint32_t& value) {
   if (r.pos + 4 > r.data.size()) return false;
   value = static_cast<std::uint32_t>(static_cast<std::uint8_t>(r.data[r.pos])) |
           (static_cast<std::uint32_t>(static_cast<std::uint8_t>(r.data[r.pos + 1])) << 8) |
           (static_cast<std::uint32_t>(static_cast<std::uint8_t>(r.data[r.pos + 2])) << 16) |
           (static_cast<std::uint32_t>(static_cast<std::uint8_t>(r.data[r.pos + 3])) << 24);
   r.pos += 4;
   return true;
 }
 
-bool parseColorModifier(Reader& r, size_t len, ParsedPreset& result) {
-  if (r.remaining() < len) return false;
-  size_t chunkEnd = r.pos + len;
+bool readByteBounded(Reader& r, size_t limit, std::uint8_t& value) {
+  if (r.pos >= limit) return false;
+  return readByte(r, value);
+}
+
+bool readU32Bounded(Reader& r, size_t limit, std::uint32_t& value) {
+  if (r.pos + 4 > limit) return false;
+  return readU32(r, value);
+}
+
+bool ensureRemaining(const Reader& r, size_t limit, size_t amount) {
+  return r.pos + amount <= limit;
+}
+
+bool parseRenderListChunk(Reader& r,
+                          size_t chunkEnd,
+                          ParsedPreset& result,
+                          std::vector<std::unique_ptr<Effect>>& chain);
+
+bool parseColorModifier(Reader& r, size_t chunkEnd, std::unique_ptr<Effect>& effect) {
   std::uint8_t version = 0;
-  if (!readByte(r, version)) return false;
+  if (!readByteBounded(r, chunkEnd, version)) return false;
   if (version != 1) {
     r.pos = chunkEnd;
     return false;
   }
   std::array<std::string, 4> scripts;
   for (size_t i = 0; i < scripts.size(); ++i) {
     std::uint32_t slen = 0;
-    if (!readU32(r, slen)) {
+    if (!readU32Bounded(r, chunkEnd, slen)) {
       r.pos = chunkEnd;
       return false;
     }
-    if (slen > chunkEnd - r.pos) {
+    size_t remaining = chunkEnd - r.pos;
+    if (slen > remaining) {
       r.pos = chunkEnd;
       return false;
     }
     if (slen > 0) {
       const char* begin = r.data.data() + r.pos;
       scripts[i].assign(begin, begin + slen);
       if (!scripts[i].empty() && scripts[i].back() == '\0') scripts[i].pop_back();
       r.pos += slen;
     } else {
       scripts[i].clear();
     }
   }
   std::uint32_t recompute = 0;
-  if (!readU32(r, recompute)) {
+  if (!readU32Bounded(r, chunkEnd, recompute)) {
     r.pos = chunkEnd;
     return false;
   }
   r.pos = chunkEnd;
-  result.chain.push_back(
-      std::make_unique<ScriptedEffect>(scripts[3], scripts[1], scripts[2], scripts[0]));
+  effect = std::make_unique<ScriptedEffect>(scripts[3], scripts[1], scripts[2], scripts[0]);
   return true;
 }
 
-ParsedPreset parseBinaryPreset(const std::vector<char>& data) {
-  ParsedPreset result;
-  Reader r{data, sizeof(kMagic) - 1};
+bool parseCommentEffect(Reader& r, size_t chunkEnd, ParsedPreset& result) {
+  std::uint32_t rawLen = 0;
+  if (!readU32Bounded(r, chunkEnd, rawLen)) {
+    r.pos = chunkEnd;
+    return false;
+  }
+  size_t strLen = static_cast<size_t>(rawLen);
+  if (strLen > chunkEnd - r.pos) {
+    r.pos = chunkEnd;
+    return false;
+  }
+  std::string text;
+  if (strLen > 0) {
+    const char* begin = r.data.data() + r.pos;
+    text.assign(begin, begin + strLen);
+    if (!text.empty() && text.back() == '\0') text.pop_back();
+    r.pos += strLen;
+  }
+  result.comments.push_back(std::move(text));
+  r.pos = chunkEnd;
+  return true;
+}
+
+bool parseRenderListChunk(Reader& r,
+                          size_t chunkEnd,
+                          ParsedPreset& result,
+                          std::vector<std::unique_ptr<Effect>>& chain) {
+  if (chunkEnd > r.data.size()) {
+    result.warnings.push_back("render list exceeds buffer bounds");
+    r.pos = r.data.size();
+    return false;
+  }
+  if (r.pos >= chunkEnd) return true;
+
   std::uint8_t modeByte = 0;
-  if (!readByte(r, modeByte)) {
+  if (!readByteBounded(r, chunkEnd, modeByte)) {
     result.warnings.push_back("incomplete preset header");
-    return result;
+    r.pos = chunkEnd;
+    return false;
   }
   std::uint32_t mode = modeByte;
   if (modeByte & 0x80u) {
     std::uint32_t ext = 0;
-    if (!readU32(r, ext)) {
+    if (!readU32Bounded(r, chunkEnd, ext)) {
       result.warnings.push_back("corrupt preset mode");
-      return result;
+      r.pos = chunkEnd;
+      return false;
     }
     mode = (modeByte & ~0x80u) | ext;
   }
   std::uint32_t extendedSize = (mode >> 24) & 0xFFu;
   size_t skip = extendedSize ? static_cast<size_t>(extendedSize) + 4u : 0u;
   if (skip > 0) {
-    if (r.remaining() < skip) {
+    if (!ensureRemaining(r, chunkEnd, skip)) {
       result.warnings.push_back("truncated extended preset data");
-      return result;
+      r.pos = chunkEnd;
+      return false;
     }
     r.pos += skip;
   }
-  while (r.remaining() >= 8) {
+
+  while (ensureRemaining(r, chunkEnd, 8)) {
     std::uint32_t effectId = 0;
     std::uint32_t payloadLen = 0;
-    if (!readU32(r, effectId) || !readU32(r, payloadLen)) break;
-    if (r.remaining() < payloadLen) {
+    if (!readU32Bounded(r, chunkEnd, effectId) || !readU32Bounded(r, chunkEnd, payloadLen)) {
+      result.warnings.push_back("truncated effect header");
+      r.pos = chunkEnd;
+      return false;
+    }
+    size_t payloadStart = r.pos;
+    size_t payloadEnd = payloadStart + static_cast<size_t>(payloadLen);
+    if (payloadEnd > chunkEnd || payloadEnd > r.data.size()) {
       result.warnings.push_back("truncated effect payload");
-      break;
+      r.pos = chunkEnd;
+      return false;
     }
-    size_t chunkStart = r.pos;
-    bool handled = false;
+
+    Reader chunkReader{r.data, payloadStart};
+    std::unique_ptr<Effect> parsedEffect;
+    bool knownEffect = false;
+    bool success = false;
+
     if (effectId == 45u) {
-      Reader chunkReader{r.data, r.pos};
-      handled = parseColorModifier(chunkReader, payloadLen, result);
+      knownEffect = true;
+      success = parseColorModifier(chunkReader, payloadEnd, parsedEffect);
+    } else if (effectId == 21u) {
+      knownEffect = true;
+      success = parseCommentEffect(chunkReader, payloadEnd, result);
+    } else if (effectId == kListId) {
+      knownEffect = true;
+      std::vector<std::unique_ptr<Effect>> nestedChain;
+      success = parseRenderListChunk(chunkReader, payloadEnd, result, nestedChain);
+      if (success) {
+        auto composite = std::make_unique<CompositeEffect>();
+        for (auto& child : nestedChain) {
+          composite->addEffect(std::move(child));
+        }
+        parsedEffect = std::move(composite);
+      }
     }
-    if (!handled) {
+
+    if (knownEffect) {
+      if (success) {
+        if (parsedEffect) {
+          chain.push_back(std::move(parsedEffect));
+        }
+      } else {
+        result.warnings.push_back("failed to parse effect index: " + std::to_string(effectId));
+      }
+    } else {
       result.warnings.push_back("unsupported effect index: " + std::to_string(effectId));
-      result.chain.push_back(std::make_unique<PassThroughEffect>());
+      chain.push_back(std::make_unique<PassThroughEffect>());
       result.unknown.push_back("effect:" + std::to_string(effectId));
     }
-    r.pos = chunkStart + payloadLen;
+
+    r.pos = payloadEnd;
+  }
+
+  if (r.pos < chunkEnd) {
+    r.pos = chunkEnd;
   }
+  return true;
+}
+
+ParsedPreset parseBinaryPreset(const std::vector<char>& data) {
+  ParsedPreset result;
+  Reader r{data, sizeof(kMagic) - 1};
+  parseRenderListChunk(r, data.size(), result, result.chain);
   return result;
 }
 
 ParsedPreset parseTextPreset(const std::string& text) {
   ParsedPreset result;
   std::istringstream stream(text);
   std::string line;
   while (std::getline(stream, line)) {
     std::string t = trim(line);
     if (t.empty() || t[0] == '#') continue;
     std::istringstream iss(t);
     std::string type;
     iss >> type;
     if (type == "blur") {
       int radius = 5;
       std::string token;
       while (iss >> token) {
         if (token.rfind("radius=", 0) == 0) {
           radius = std::stoi(token.substr(7));
         } else {
           result.unknown.push_back(token);
         }
       }
       result.chain.push_back(std::make_unique<BlurEffect>(radius));
     } else if (type == "colormap") {
diff --git a/tests/avs_core_tests.cpp b/tests/avs_core_tests.cpp
index c7df5f48ae9f9abc7aaa2df8d906fe1f2daf1a36..3d7d7c45c64e28cfd3e529c4149a52819198d8d9 100644
--- a/tests/avs_core_tests.cpp
+++ b/tests/avs_core_tests.cpp
@@ -171,50 +171,63 @@ TEST(AdditiveBlendEffect, AddsConstant) {
 }
 
 TEST(PresetParser, ParsesChainAndReportsUnsupported) {
   auto tmp = std::filesystem::temp_directory_path() / "test.avs";
   {
     std::ofstream(tmp) << "blur radius=2\nunknown\n";
   }
   auto preset = avs::parsePreset(tmp);
   EXPECT_EQ(preset.chain.size(), 2u);
   EXPECT_TRUE(dynamic_cast<avs::BlurEffect*>(preset.chain[0].get()) != nullptr);
   EXPECT_EQ(preset.warnings.size(), 1u);
   std::filesystem::remove(tmp);
 }
 
 TEST(PresetParser, ParsesBinaryColorModifier) {
   auto preset = avs::parsePreset(std::filesystem::path(SOURCE_DIR) / "tests/data/simple.avs");
   ASSERT_EQ(preset.chain.size(), 1u);
   auto* scripted = dynamic_cast<avs::ScriptedEffect*>(preset.chain[0].get());
   ASSERT_NE(scripted, nullptr);
   EXPECT_TRUE(scripted->initScript().empty());
   EXPECT_TRUE(scripted->beatScript().empty());
   EXPECT_EQ(scripted->frameScript(), "red=bass; green=mid; blue=treb;");
   EXPECT_EQ(scripted->pixelScript(), "red=red; green=green; blue=blue;");
 }
 
+TEST(PresetParser, ParsesNestedRenderLists) {
+  auto preset = avs::parsePreset(std::filesystem::path(SOURCE_DIR) /
+                                 "tests/data/nested_list.avs");
+  EXPECT_TRUE(preset.warnings.empty());
+  ASSERT_EQ(preset.chain.size(), 1u);
+  auto* composite = dynamic_cast<avs::CompositeEffect*>(preset.chain[0].get());
+  ASSERT_NE(composite, nullptr);
+  ASSERT_EQ(composite->childCount(), 1u);
+  EXPECT_NE(dynamic_cast<avs::ScriptedEffect*>(composite->children()[0].get()), nullptr);
+  ASSERT_EQ(preset.comments.size(), 1u);
+  EXPECT_EQ(preset.comments[0], "Nested list comment");
+}
+
 TEST(FileWatcher, DetectsModification) {
   auto tmp = std::filesystem::temp_directory_path() / "watch.txt";
   {
     std::ofstream(tmp) << "a";
   }
   avs::FileWatcher w(tmp);
   {
     std::ofstream(tmp) << "b";
   }
   bool changed = false;
   for (int i = 0; i < 10 && !changed; ++i) {
     std::this_thread::sleep_for(std::chrono::milliseconds(10));
     changed = w.poll();
   }
   EXPECT_TRUE(changed);
   std::filesystem::remove(tmp);
 }
 
 TEST(PortAudioCallback, NullInputRaisesUnderflowFlag) {
   std::vector<float> ring(8, 1.0f);
   const size_t mask = ring.size() - 1;
   const size_t writeIndex = 2;
   const size_t samples = 4;
 
   auto result =
diff --git a/tests/data/nested_list.avs b/tests/data/nested_list.avs
new file mode 100644
index 0000000000000000000000000000000000000000..65ace07ddc5ff63c2480524017cda3de248d7981
GIT binary patch
literal 160
zcmXwwK?=e^3`NsBD2S_g07cvmv+x3?Aaq+g_A7;%7AEQS9b?tNds*bAUSgE_p?qy`
z+++xp&!@|twnVfuHbxCm3>-&MzRxLPQhJqAI=j))XpQP%${4)i_?dypuXY^b0{@XC
W{zah|`B!PQhqcj+;H>ygW$O(e%_}Yd

literal 0
HcmV?d00001

