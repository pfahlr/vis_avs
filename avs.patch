diff --git a/libs/CMakeLists.txt b/libs/CMakeLists.txt
index 29439e73efbafd7548793d172ab2f60a7e457f13..a67bb0c459d8c0b936b2808d88c0037cdaa23629 100644
--- a/libs/CMakeLists.txt
+++ b/libs/CMakeLists.txt
@@ -1,3 +1,6 @@
 add_subdirectory(third_party/ns-eel)
 add_subdirectory(avs-core)
-add_subdirectory(avs-platform)
+option(AVS_BUILD_PLATFORM "Build SDL/OpenGL platform layer" ON)
+if(AVS_BUILD_PLATFORM)
+  add_subdirectory(avs-platform)
+endif()
diff --git a/libs/avs-core/include/avs/effects.hpp b/libs/avs-core/include/avs/effects.hpp
index 445c69cf5664c34bfd6956bcdfa3b9809226c0fe..aec7ac198396395fe5648206878d34e2344bd0ca 100644
--- a/libs/avs-core/include/avs/effects.hpp
+++ b/libs/avs-core/include/avs/effects.hpp
@@ -94,45 +94,70 @@ class TunnelEffect : public Effect {
   void process(const Framebuffer& in, Framebuffer& out) override;
 
  private:
   int cx_ = 0;
   int cy_ = 0;
 };
 
 class RadialBlurEffect : public Effect {
  public:
   void init(int w, int h) override;
   void process(const Framebuffer& in, Framebuffer& out) override;
 };
 
 class AdditiveBlendEffect : public Effect {
  public:
   void init(int w, int h) override;
   void process(const Framebuffer& in, Framebuffer& out) override;
 
  private:
   Framebuffer blend_;
 };
 
 class ScriptedEffect : public Effect {
  public:
   ScriptedEffect(std::string frameScript, std::string pixelScript);
+  ScriptedEffect(std::string initScript,
+                 std::string frameScript,
+                 std::string beatScript,
+                 std::string pixelScript);
+  ~ScriptedEffect() override;
   void init(int w, int h) override;
   void process(const Framebuffer& in, Framebuffer& out) override;
   void update(float time, int frame, const AudioState& audio);
   void setScripts(std::string frameScript, std::string pixelScript);
+  void setScripts(std::string initScript,
+                  std::string frameScript,
+                  std::string beatScript,
+                  std::string pixelScript);
+  const std::string& initScript() const { return initScript_; }
+  const std::string& frameScript() const { return frameScript_; }
+  const std::string& beatScript() const { return beatScript_; }
+  const std::string& pixelScript() const { return pixelScript_; }
 
  private:
+  void setAllScripts(std::string initScript,
+                     std::string frameScript,
+                     std::string beatScript,
+                     std::string pixelScript);
+  void compile();
   EelVm vm_;
+  NSEEL_CODEHANDLE initCode_ = nullptr;
   NSEEL_CODEHANDLE frameCode_ = nullptr;
+  NSEEL_CODEHANDLE beatCode_ = nullptr;
   NSEEL_CODEHANDLE pixelCode_ = nullptr;
+  std::string initScript_;
   std::string frameScript_;
+  std::string beatScript_;
   std::string pixelScript_;
   bool dirty_ = true;
+  bool initRan_ = false;
+  bool pendingBeat_ = false;
+  float lastRms_ = 0.0f;
   EEL_F *time_ = nullptr, *frame_ = nullptr, *bass_ = nullptr, *mid_ = nullptr, *treb_ = nullptr,
-        *rms_ = nullptr;
+        *rms_ = nullptr, *beat_ = nullptr;
   EEL_F *x_ = nullptr, *y_ = nullptr, *r_ = nullptr, *g_ = nullptr, *b_ = nullptr;
   int w_ = 0;
   int h_ = 0;
 };
 
 }  // namespace avs
diff --git a/libs/avs-core/src/effects/scripted.cpp b/libs/avs-core/src/effects/scripted.cpp
index 6dc099f2f44d5365a26b31a6b1ca8286c725aa38..5916c309dc088fafa163999c4f52cc95cb0f42d4 100644
--- a/libs/avs-core/src/effects/scripted.cpp
+++ b/libs/avs-core/src/effects/scripted.cpp
@@ -1,68 +1,148 @@
 #include <algorithm>
 
 #include "avs/effects.hpp"
 
 namespace avs {
 
-ScriptedEffect::ScriptedEffect(std::string frameScript, std::string pixelScript)
-    : frameScript_(std::move(frameScript)), pixelScript_(std::move(pixelScript)) {}
+ScriptedEffect::ScriptedEffect(std::string frameScript, std::string pixelScript) {
+  setAllScripts("", std::move(frameScript), "", std::move(pixelScript));
+}
+
+ScriptedEffect::ScriptedEffect(std::string initScript,
+                               std::string frameScript,
+                               std::string beatScript,
+                               std::string pixelScript) {
+  setAllScripts(std::move(initScript),
+                std::move(frameScript),
+                std::move(beatScript),
+                std::move(pixelScript));
+}
+
+ScriptedEffect::~ScriptedEffect() {
+  if (initCode_) vm_.freeCode(initCode_);
+  if (frameCode_) vm_.freeCode(frameCode_);
+  if (beatCode_) vm_.freeCode(beatCode_);
+  if (pixelCode_) vm_.freeCode(pixelCode_);
+}
 
 void ScriptedEffect::setScripts(std::string frameScript, std::string pixelScript) {
+  setAllScripts("", std::move(frameScript), "", std::move(pixelScript));
+}
+
+void ScriptedEffect::setScripts(std::string initScript,
+                                std::string frameScript,
+                                std::string beatScript,
+                                std::string pixelScript) {
+  setAllScripts(std::move(initScript),
+                std::move(frameScript),
+                std::move(beatScript),
+                std::move(pixelScript));
+}
+
+void ScriptedEffect::setAllScripts(std::string initScript,
+                                   std::string frameScript,
+                                   std::string beatScript,
+                                   std::string pixelScript) {
+  initScript_ = std::move(initScript);
   frameScript_ = std::move(frameScript);
+  beatScript_ = std::move(beatScript);
   pixelScript_ = std::move(pixelScript);
   dirty_ = true;
+  pendingBeat_ = false;
 }
 
 void ScriptedEffect::init(int w, int h) {
   w_ = w;
   h_ = h;
   time_ = vm_.regVar("time");
   frame_ = vm_.regVar("frame");
   bass_ = vm_.regVar("bass");
   mid_ = vm_.regVar("mid");
   treb_ = vm_.regVar("treb");
   rms_ = vm_.regVar("rms");
+  beat_ = vm_.regVar("beat");
   x_ = vm_.regVar("x");
   y_ = vm_.regVar("y");
   r_ = vm_.regVar("red");
   g_ = vm_.regVar("green");
   b_ = vm_.regVar("blue");
+  lastRms_ = 0.0f;
+  initRan_ = false;
+  pendingBeat_ = false;
 }
 
 void ScriptedEffect::update(float time, int frame, const AudioState& audio) {
   if (time_) *time_ = time;
   if (frame_) *frame_ = frame;
   if (bass_) *bass_ = audio.bands[0];
   if (mid_) *mid_ = audio.bands[1];
   if (treb_) *treb_ = audio.bands[2];
   if (rms_) *rms_ = audio.rms;
+  if (beat_) {
+    const float threshold = 0.6f;
+    const bool isBeat = audio.rms > threshold && lastRms_ <= threshold;
+    *beat_ = isBeat ? 1.0 : 0.0;
+    pendingBeat_ = pendingBeat_ || isBeat;
+    lastRms_ = audio.rms;
+  }
 }
 
-void ScriptedEffect::process(const Framebuffer& /*in*/, Framebuffer& out) {
-  if (dirty_) {
-    if (frameCode_) vm_.freeCode(frameCode_);
-    if (pixelCode_) vm_.freeCode(pixelCode_);
-    frameCode_ = vm_.compile(frameScript_);
-    pixelCode_ = vm_.compile(pixelScript_);
-    dirty_ = false;
+void ScriptedEffect::compile() {
+  if (!dirty_) return;
+  if (initCode_) {
+    vm_.freeCode(initCode_);
+    initCode_ = nullptr;
+  }
+  if (frameCode_) {
+    vm_.freeCode(frameCode_);
+    frameCode_ = nullptr;
+  }
+  if (beatCode_) {
+    vm_.freeCode(beatCode_);
+    beatCode_ = nullptr;
   }
+  if (pixelCode_) {
+    vm_.freeCode(pixelCode_);
+    pixelCode_ = nullptr;
+  }
+  if (!initScript_.empty()) initCode_ = vm_.compile(initScript_);
+  if (!frameScript_.empty()) frameCode_ = vm_.compile(frameScript_);
+  if (!beatScript_.empty()) beatCode_ = vm_.compile(beatScript_);
+  if (!pixelScript_.empty()) pixelCode_ = vm_.compile(pixelScript_);
+  dirty_ = false;
+  initRan_ = false;
+}
 
-  vm_.execute(frameCode_);
+void ScriptedEffect::process(const Framebuffer& /*in*/, Framebuffer& out) {
+  compile();
+
+  if (!out.rgba.empty()) {
+    std::fill(out.rgba.begin(), out.rgba.end(), 0);
+  }
+  if (!initRan_) {
+    if (initCode_) vm_.execute(initCode_);
+    initRan_ = true;
+  }
+  if (frameCode_) vm_.execute(frameCode_);
+  if (pendingBeat_) {
+    if (beatCode_) vm_.execute(beatCode_);
+    pendingBeat_ = false;
+  }
   for (int py = 0; py < h_; ++py) {
     if (y_) *y_ = py;
     for (int px = 0; px < w_; ++px) {
       if (x_) *x_ = px;
-      vm_.execute(pixelCode_);
+      if (pixelCode_) vm_.execute(pixelCode_);
       int idx = (py * w_ + px) * 4;
       auto toByte = [](double v) {
         return static_cast<std::uint8_t>(std::clamp(v, 0.0, 1.0) * 255.0 + 0.5);
       };
       out.rgba[idx + 0] = toByte(r_ ? *r_ : 0.0);
       out.rgba[idx + 1] = toByte(g_ ? *g_ : 0.0);
       out.rgba[idx + 2] = toByte(b_ ? *b_ : 0.0);
       out.rgba[idx + 3] = 255;
     }
   }
 }
 
 }  // namespace avs
diff --git a/libs/avs-core/src/preset.cpp b/libs/avs-core/src/preset.cpp
index 6a6a351780fb09af32f474267f5985e481f69781..6298154dcbd238aa5bc7586788c073df9ea3c012 100644
--- a/libs/avs-core/src/preset.cpp
+++ b/libs/avs-core/src/preset.cpp
@@ -1,68 +1,200 @@
 #include "avs/preset.hpp"
 
+#include <algorithm>
+#include <array>
 #include <cctype>
+#include <cstdint>
 #include <fstream>
+#include <iterator>
 #include <sstream>
 #include <string>
+#include <vector>
 
 namespace avs {
 
 namespace {
 std::string trim(const std::string& s) {
   size_t b = 0;
   while (b < s.size() && std::isspace(static_cast<unsigned char>(s[b]))) ++b;
   size_t e = s.size();
   while (e > b && std::isspace(static_cast<unsigned char>(s[e - 1]))) --e;
   return s.substr(b, e - b);
 }
 
 class PassThroughEffect : public Effect {
  public:
   void process(const Framebuffer& in, Framebuffer& out) override { out = in; }
 };
-}  // namespace
 
-ParsedPreset parsePreset(const std::filesystem::path& file) {
+constexpr const char kMagic[] = "Nullsoft AVS Preset 0.2\x1a";
+
+struct Reader {
+  const std::vector<char>& data;
+  size_t pos = 0;
+
+  size_t remaining() const { return data.size() - pos; }
+};
+
+bool readByte(Reader& r, std::uint8_t& value) {
+  if (r.pos >= r.data.size()) return false;
+  value = static_cast<std::uint8_t>(r.data[r.pos++]);
+  return true;
+}
+
+bool readU32(Reader& r, std::uint32_t& value) {
+  if (r.pos + 4 > r.data.size()) return false;
+  value = static_cast<std::uint32_t>(static_cast<std::uint8_t>(r.data[r.pos])) |
+          (static_cast<std::uint32_t>(static_cast<std::uint8_t>(r.data[r.pos + 1])) << 8) |
+          (static_cast<std::uint32_t>(static_cast<std::uint8_t>(r.data[r.pos + 2])) << 16) |
+          (static_cast<std::uint32_t>(static_cast<std::uint8_t>(r.data[r.pos + 3])) << 24);
+  r.pos += 4;
+  return true;
+}
+
+bool parseColorModifier(Reader& r, size_t len, ParsedPreset& result) {
+  if (r.remaining() < len) return false;
+  size_t chunkEnd = r.pos + len;
+  std::uint8_t version = 0;
+  if (!readByte(r, version)) return false;
+  if (version != 1) {
+    r.pos = chunkEnd;
+    return false;
+  }
+  std::array<std::string, 4> scripts;
+  for (size_t i = 0; i < scripts.size(); ++i) {
+    std::uint32_t slen = 0;
+    if (!readU32(r, slen)) {
+      r.pos = chunkEnd;
+      return false;
+    }
+    if (slen > chunkEnd - r.pos) {
+      r.pos = chunkEnd;
+      return false;
+    }
+    if (slen > 0) {
+      const char* begin = r.data.data() + r.pos;
+      scripts[i].assign(begin, begin + slen);
+      if (!scripts[i].empty() && scripts[i].back() == '\0') scripts[i].pop_back();
+      r.pos += slen;
+    } else {
+      scripts[i].clear();
+    }
+  }
+  std::uint32_t recompute = 0;
+  if (!readU32(r, recompute)) {
+    r.pos = chunkEnd;
+    return false;
+  }
+  r.pos = chunkEnd;
+  result.chain.push_back(
+      std::make_unique<ScriptedEffect>(scripts[3], scripts[1], scripts[2], scripts[0]));
+  return true;
+}
+
+ParsedPreset parseBinaryPreset(const std::vector<char>& data) {
   ParsedPreset result;
-  std::ifstream f(file);
-  if (!f) {
-    result.warnings.push_back("failed to open preset");
+  Reader r{data, sizeof(kMagic) - 1};
+  std::uint8_t modeByte = 0;
+  if (!readByte(r, modeByte)) {
+    result.warnings.push_back("incomplete preset header");
     return result;
   }
+  std::uint32_t mode = modeByte;
+  if (modeByte & 0x80u) {
+    std::uint32_t ext = 0;
+    if (!readU32(r, ext)) {
+      result.warnings.push_back("corrupt preset mode");
+      return result;
+    }
+    mode = (modeByte & ~0x80u) | ext;
+  }
+  std::uint32_t extendedSize = (mode >> 24) & 0xFFu;
+  size_t skip = extendedSize ? static_cast<size_t>(extendedSize) + 4u : 0u;
+  if (skip > 0) {
+    if (r.remaining() < skip) {
+      result.warnings.push_back("truncated extended preset data");
+      return result;
+    }
+    r.pos += skip;
+  }
+  while (r.remaining() >= 8) {
+    std::uint32_t effectId = 0;
+    std::uint32_t payloadLen = 0;
+    if (!readU32(r, effectId) || !readU32(r, payloadLen)) break;
+    if (r.remaining() < payloadLen) {
+      result.warnings.push_back("truncated effect payload");
+      break;
+    }
+    size_t chunkStart = r.pos;
+    bool handled = false;
+    if (effectId == 45u) {
+      Reader chunkReader{r.data, r.pos};
+      handled = parseColorModifier(chunkReader, payloadLen, result);
+    }
+    if (!handled) {
+      result.warnings.push_back("unsupported effect index: " + std::to_string(effectId));
+      result.chain.push_back(std::make_unique<PassThroughEffect>());
+      result.unknown.push_back("effect:" + std::to_string(effectId));
+    }
+    r.pos = chunkStart + payloadLen;
+  }
+  return result;
+}
+
+ParsedPreset parseTextPreset(const std::string& text) {
+  ParsedPreset result;
+  std::istringstream stream(text);
   std::string line;
-  while (std::getline(f, line)) {
+  while (std::getline(stream, line)) {
     std::string t = trim(line);
     if (t.empty() || t[0] == '#') continue;
     std::istringstream iss(t);
     std::string type;
     iss >> type;
     if (type == "blur") {
       int radius = 5;
       std::string token;
       while (iss >> token) {
         if (token.rfind("radius=", 0) == 0) {
           radius = std::stoi(token.substr(7));
         } else {
           result.unknown.push_back(token);
         }
       }
       result.chain.push_back(std::make_unique<BlurEffect>(radius));
     } else if (type == "colormap") {
       result.chain.push_back(std::make_unique<ColorMapEffect>());
     } else if (type == "convolution") {
       result.chain.push_back(std::make_unique<ConvolutionEffect>());
     } else if (type == "scripted") {
       std::string script;
       std::getline(iss, script);
       script = trim(script);
-      result.chain.push_back(std::make_unique<ScriptedEffect>(script, ""));
+      result.chain.push_back(std::make_unique<ScriptedEffect>("", script, "", ""));
     } else {
       result.warnings.push_back("unsupported effect: " + type);
       result.chain.push_back(std::make_unique<PassThroughEffect>());
       result.unknown.push_back(t);
     }
   }
   return result;
 }
 
+}  // namespace
+
+ParsedPreset parsePreset(const std::filesystem::path& file) {
+  ParsedPreset result;
+  std::ifstream f(file, std::ios::binary);
+  if (!f) {
+    result.warnings.push_back("failed to open preset");
+    return result;
+  }
+  std::vector<char> buffer((std::istreambuf_iterator<char>(f)), std::istreambuf_iterator<char>());
+  if (buffer.size() >= sizeof(kMagic) - 1 &&
+      std::equal(kMagic, kMagic + sizeof(kMagic) - 1, buffer.begin())) {
+    return parseBinaryPreset(buffer);
+  }
+  return parseTextPreset(std::string(buffer.begin(), buffer.end()));
+}
+
 }  // namespace avs
diff --git a/tests/CMakeLists.txt b/tests/CMakeLists.txt
index 78ef36c2915fc2b077a99ec0121282c20307c97a..e36519fe5160dd96a92822da35923ee4027dc220 100644
--- a/tests/CMakeLists.txt
+++ b/tests/CMakeLists.txt
@@ -1,13 +1,23 @@
-find_package(GTest REQUIRED)
+include(FetchContent)
+find_package(GTest QUIET)
+if(NOT GTest_FOUND)
+  FetchContent_Declare(
+    googletest
+    URL https://github.com/google/googletest/archive/refs/tags/v1.14.0.zip)
+  set(BUILD_GMOCK OFF CACHE BOOL "" FORCE)
+  set(INSTALL_GTEST OFF CACHE BOOL "" FORCE)
+  FetchContent_MakeAvailable(googletest)
+endif()
 
 add_executable(avs_core_tests avs_core_tests.cpp)
 target_link_libraries(avs_core_tests PRIVATE avs-core avs-platform GTest::gtest_main)
 target_compile_options(avs_core_tests PRIVATE -Wall -Wextra -Werror)
+target_compile_definitions(avs_core_tests PRIVATE BUILD_DIR="${CMAKE_BINARY_DIR}" SOURCE_DIR="${CMAKE_SOURCE_DIR}")
 add_test(NAME avs_core_tests COMMAND avs_core_tests)
 
 add_executable(deterministic_render_test deterministic_render_test.cpp)
 target_link_libraries(deterministic_render_test PRIVATE GTest::gtest_main)
 target_compile_options(deterministic_render_test PRIVATE -Wall -Wextra -Werror)
 target_compile_definitions(deterministic_render_test PRIVATE BUILD_DIR="${CMAKE_BINARY_DIR}" SOURCE_DIR="${CMAKE_SOURCE_DIR}")
 add_test(NAME deterministic_render_test COMMAND deterministic_render_test)
 add_dependencies(deterministic_render_test avs-player)
diff --git a/tests/avs_core_tests.cpp b/tests/avs_core_tests.cpp
index 19910f8db26ddc4d6c77c3b1ef70bed114c01040..2cd9ec0cab614fdbe42f39143389500348ef39b0 100644
--- a/tests/avs_core_tests.cpp
+++ b/tests/avs_core_tests.cpp
@@ -160,50 +160,61 @@ TEST(RadialBlurEffect, AveragesWithCenter) {
 
 TEST(AdditiveBlendEffect, AddsConstant) {
   Framebuffer in;
   in.w = 1;
   in.h = 1;
   in.rgba = {100, 100, 100, 100};
   Framebuffer out;
   AdditiveBlendEffect ab;
   ab.init(in.w, in.h);
   ab.process(in, out);
   EXPECT_EQ(checksum(out), 440u);
 }
 
 TEST(PresetParser, ParsesChainAndReportsUnsupported) {
   auto tmp = std::filesystem::temp_directory_path() / "test.avs";
   {
     std::ofstream(tmp) << "blur radius=2\nunknown\n";
   }
   auto preset = avs::parsePreset(tmp);
   EXPECT_EQ(preset.chain.size(), 2u);
   EXPECT_TRUE(dynamic_cast<avs::BlurEffect*>(preset.chain[0].get()) != nullptr);
   EXPECT_EQ(preset.warnings.size(), 1u);
   std::filesystem::remove(tmp);
 }
 
+TEST(PresetParser, ParsesBinaryColorModifier) {
+  auto preset = avs::parsePreset(std::filesystem::path(SOURCE_DIR) / "tests/data/simple.avs");
+  ASSERT_EQ(preset.chain.size(), 1u);
+  auto* scripted = dynamic_cast<avs::ScriptedEffect*>(preset.chain[0].get());
+  ASSERT_NE(scripted, nullptr);
+  EXPECT_TRUE(scripted->initScript().empty());
+  EXPECT_TRUE(scripted->beatScript().empty());
+  EXPECT_EQ(scripted->frameScript(), "red=bass; green=mid; blue=treb;");
+  EXPECT_EQ(scripted->pixelScript(), "red=red; green=green; blue=blue;");
+}
+
 TEST(FileWatcher, DetectsModification) {
   auto tmp = std::filesystem::temp_directory_path() / "watch.txt";
   {
     std::ofstream(tmp) << "a";
   }
   avs::FileWatcher w(tmp);
   {
     std::ofstream(tmp) << "b";
   }
   bool changed = false;
   for (int i = 0; i < 10 && !changed; ++i) {
     std::this_thread::sleep_for(std::chrono::milliseconds(10));
     changed = w.poll();
   }
   EXPECT_TRUE(changed);
   std::filesystem::remove(tmp);
 }
 
 TEST(PortAudioCallback, NullInputRaisesUnderflowFlag) {
   std::vector<float> ring(8, 1.0f);
   const size_t mask = ring.size() - 1;
   const size_t writeIndex = 2;
   const size_t samples = 4;
 
   auto result =
diff --git a/tests/data/simple.avs b/tests/data/simple.avs
index 733eab13cb412aa31f58f4c842fea16b0f65ab1d..3e8ff30e7a0e91949dd0595105d195ee11f7602f 100644
GIT binary patch
literal 119
zcmeY(&B-awPb*Py3=38WC`v6(Em1JgGm>J^Wnf?k17b!+AW@W>VhhC93h70usd=_w
q(pn)Yr!>_TL|8K@Koun=78k=*<z@mkfYp=~r6ySeRX_kEkOBb4<R3u*

literal 95
zcmWNF!3h8%3<UpHv2bO`6{BX6fO?X|{?Et2%sg<Ndl15)O<n4t4cq7p9M{!Rj_8M4
dmU!}Jx`P6{ymz{1bR*ZTsghC0;q@@qoPK^UAu|8~

